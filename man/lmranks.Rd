% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lmranks.R, R/lmranks_model_usage.R,
%   R/lmranks_summary.R
\name{lmranks}
\alias{lmranks}
\alias{plot.lmranks}
\alias{predict.lmranks}
\alias{summary.lmranks}
\alias{vcov.lmranks}
\title{Rank-Rank Regression}
\usage{
lmranks(
  formula,
  data,
  subset,
  weights,
  na.action = stats::na.fail,
  method = "qr",
  model = TRUE,
  x = FALSE,
  qr = TRUE,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset = offset,
  omega = 1,
  ...
)

\method{plot}{lmranks}(x, which = 1, ...)

\method{predict}{lmranks}(object, newdata, ...)

\method{summary}{lmranks}(object, correlation = FALSE, symbolic.cor = FALSE, ...)

\method{vcov}{lmranks}(object, complete = TRUE, ...)
}
\arguments{
\item{formula}{An object of class "\code{\link{formula}}": a symbolic description
of the model to be fitted. Exactly like the formula for linear model except that
variables to be ranked can be indicated by \code{r()}. See Details and Examples below.}

\item{data}{an optional data frame, list or environment (or object
    coercible by \code{\link{as.data.frame}} to a data frame) containing
    the variables in the model.  If not found in \code{data}, the
    variables are taken from \code{environment(formula)},
    typically the environment from which \code{lm} is called.}

\item{subset}{currently not supported.}

\item{weights}{currently not supported.}

\item{na.action}{currently not supported. User is expected to handle NA values on their own.}

\item{method}{the method to be used; for fitting, currently only
    \code{method = "qr"} is supported; \code{method = "model.frame"} returns
    the model frame (the same as with \code{model = TRUE}, see below).}

\item{model, y, qr}{logicals. If TRUE the corresponding components of the fit (the model frame, the response, the QR decomposition) are returned.}

\item{x}{\itemize{
\item{For \code{lmranks}: }{Logical. Should model matrix be returned?}
\item{For \code{plot} method: }{An \code{lmranks} object.}
}}

\item{singular.ok}{logical. If \code{FALSE} (the default in S but
    not in \R) a singular fit is an error.}

\item{contrasts}{an optional list. See the \code{contrasts.arg}
    of \code{\link[stats]{model.matrix.default}}.}

\item{offset}{this can be used to specify an \emph{a priori} known
    component to be included in the linear predictor during fitting.
    This should be \code{NULL} or a numeric vector or matrix of extents
    matching those of the response.  One or more \code{\link[stats]{offset}} terms can be
    included in the formula instead or as well, and if more than one are
    specified their sum is used.  See \code{\link[stats]{model.offset}}.}

\item{omega}{real number in the interval [0,1] defining how ties are handled. The value of \code{omega} is passed to \code{\link{frank}} for computation of ranks. The default is 1 so that ranks are defined as the empirical cdf evaluated at the variable. See Details below.}

\item{...}{For \code{lm()}: additional arguments to be passed to the low level
    regression fitting functions (see below).}

\item{which}{As in \code{\link{plot.lm}}. Currently only no.1 is available.}

\item{object}{A \code{lmranks} object.}

\item{newdata}{An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.}

\item{correlation}{logical; if \code{TRUE}, the correlation matrix of
    the estimated parameters is returned and printed.}

\item{symbolic.cor}{logical. If \code{TRUE}, print the correlations in
    a symbolic form (see \code{\link[stats]{symnum}}) rather than as numbers.}

\item{complete}{logical indicating if the full variance-covariance matrix 
should be returned also in case of an over-determined system where 
some coefficients are undefined and \code{coef(.)} contains NAs correspondingly. 
When \code{complete = TRUE}, \code{vcov()} is compatible with \code{coef()} also in this singular case.}
}
\value{
An object of class \code{lmranks}, inheriting (as well as possible) from class \code{lm}.

Additionally, it has an \code{omega} entry, corresponding to \code{omega} argument,
a \code{ranked_response} logical entry, and 
a \code{rank_terms_indices} - an integer vector with indices of entries of \code{terms.labels} attribute
of \code{terms(formula)}, which correspond to ranked regressors.

A number of methods defined for \code{lm} does not yield theoretically correct 
results when applied to \code{lmranks} objects; errors or warnings are raised consciously.
Also, the \code{df.residual} component is set to NA, since the notion of effects of freedom
for the rank models is not theoretically established (at time of 1.2 release).
}
\description{
Estimate a rank-rank regression in which the outcome and/or regressor are ranked.
Optionally, when the dataset is divided into groups, rank-rank regressions can be run
separately within each group, but with ranks computed based on entire dataset 
(for that, see the corresponding section below).
}
\details{
This function is useful in case when relationship not between variables themselves, but their ranks
(or, put differently, their ECDF value) is of interest. The variables to be ranked
(both regressors and response) can be marked with \code{r()}. A typical formula looks like
\code{r(Y)~r(X)+W1+W2+...} and corresponds to modelling rank of Y
as a linear function of rank of X and other, non-ranked regressors. 

This function is as consistent with \code{lm} function as possible. For instance, 
\code{.} in formula means 'all columns not otherwise in the formula' - same as in \code{lm}. 
Intercept is included by default.
In model specified as \code{r(Y)~r(X)+.}, both \code{r(X)} and \code{X} will be
included in the model - as it would have been in \code{lm} and, say, 
\code{log()} instead of \code{r()}. 
One can exclude \code{X} with a \code{-}, i.e. \code{r(Y)~r(X)+.-X}. See
\code{\link{formula}} for more about model specification.

The \code{r()} is a private alias for \code{\link{frank}} with \code{increasing} 
argument fixed as TRUE. \code{omega} argument may be specified globally 
(as a specification of definition of rank) in the call to \code{lmranks}. 
By default \code{r}'s outcome is equivalent to \code{\link[stats]{ecdf}}'s.

In version 1.2, only models with at most one rank regressor are available. The single 
response might be either ranked or continuous.

Many functions defined for \code{lm} also work correctly with \code{lmranks}.
These include \code{\link[stats]{coef}}, \code{\link[stats]{model.frame}},
\code{\link[stats]{model.matrix}}, \code{\link[stats]{resid}}, 
\code{\link[stats]{update}} and others. 
On the other hand, some would return incorrect results if they treated
\code{lmranks} output in the same way as \code{lm}'s. The central contribution of this package
are \code{vcov}, \code{summary} and \code{confint} implementations using asymptotically consistent theory.
Another example is \code{AIC},
which needs the number of parameters of the model. At the moment of 1.2 release this
is not theoretically developed for rank-rank regressions and thus NA is returned.

See the \code{\link{lm}} documentation for more.
}
\section{Methods (by generic)}{
\itemize{
\item \code{plot(lmranks)}: Plot diagnostics for an \code{lmranks} object

Displays plots useful for assessing quality of model fit. Currently, only one
plot is available, which plots fitted values against residuals (for homoscedacity check).

\item \code{predict(lmranks)}: Predict method for Linear Model for Ranks Fits

\item \code{summary(lmranks)}: Summarizing fits of rank-rank regressions

\item \code{vcov(lmranks)}: Calculate Variance-Covariance Matrix for a Fitted \code{lmranks} object

Returns the variance-covariance matrix of the regression coefficients 
(main parameters) of a fitted \code{lmranks} object. Its result is theoretically valid 
and asymptotically consistent, in contrast to naively running \code{vcov(lm(...))}.

}}
\section{Rank regressions with groups/clusters}{


Sometimes, the data is divided into groups (or \emph{clusters}) and the researcher is
interested in running rank-rank regressions separately within each group, but with
ranks computed based on entire dataset. 

This case is implemented and can be specified using formula interaction notation.
Suppose, that G is the name of the grouping variable (it \strong{must} be a \code{\link{factor}}),
\code{r(Y)} is the ranked response, \code{r(X)} is the ranked regressor and
\code{W} are the usual regressors. A formula for this model is \code{r(Y)~(r(X)+W):G}.

Since theory for regression with grouped and ungrouped regressors is not yet developed,
specifying such a model will raise an error. Also, by default the intercept is 
treated group-wise; \code{r(Y)~(r(X)+W):G} will actually become \code{r(Y)~(r(X)+W):G+G-1}.

\code{\link[stats]{contrasts}} of \code{G} must be of \code{contr.treatment} kind, 
which is the default.
}

\section{Warning}{

As a consequence of the order, in which \code{\link[stats]{model.frame}} applies operations, 
\code{subset} and \code{na.action} would be applied after evaluation of \code{r()}. 
That would drop some rank values from the final model frame and returned coefficients 
and standard errors could no longer be correct.
The user must handle the NA values and may filter the data on his/her own.

Wrapping \code{r()} with other functions (like \code{log(r(x))}) will not 
recognize correctly the mark (because it will not be caught in \code{terms(formula, specials = "r")}).
The ranks will be calculated correctly, but their transformation will be treated later in \code{lm} as a regular
regressor. This means, that the corresponding regression coefficient will be calculated correctly,
but the standard errors, statistics etc. will not. 

\code{r}, \code{.r_predict} and \code{.r_cache} are special expressions, used
internally to interpret \code{r} mark correctly. Do not use them in \code{formula}.
}

\examples{
Y <- c(3,1,2,4,5)
y_frank <- c(0.6, 1.0, 0.8, 0.4, 0.2)
X <- 1:5
omega <- 0.5
x_frank <- c(1.0, 0.8, 0.6, 0.4, 0.2)
W <- matrix(y_frank * 0.1 + 5 + rnorm(5, sd = 0.1), ncol = 1)

lmr <- lmranks(r(Y) ~ r(X) + W)
lmr
# naive version with same regression coefficients, but incorrect 
# standard errors and statistics:
lmm <- lm(y_frank ~ x_frank + W)

# Compare:
summary(lmr)
summary(lmm)

# Support of `data` argument:
data(mtcars)
lmranks(r(mpg) ~ r(hp) + ., data = mtcars)
# Same as above, but use the `hp` variable only through its rank
lmranks(r(mpg) ~ r(hp) + . - hp, data = mtcars)

# Grouped case:
G <- factor(rep(LETTERS[1:4], each=nrow(mtcars) / 4))
lmr <- lmranks(r(mpg) ~ r(hp):G, data = mtcars)
lmr
model.matrix(lmr)
# Include all columns of mtcars as usual covariates:
lmranks(r(mpg) ~ (r(hp) + .):G, data = mtcars)

}
\seealso{
\code{\link{lm}} for details about other arguments; \code{\link{frank}}.

Generic funcions \code{\link[stats]{coef}}, \code{\link[stats]{effects}}, 
\code{\link[stats]{residuals}},
\code{\link[stats]{fitted}}, \code{\link[stats]{model.frame}},
\code{\link[stats]{model.matrix}}, \code{\link[stats]{update}} .
}
