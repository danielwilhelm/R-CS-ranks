% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lmranks.R, R/lmranks_model_usage.R,
%   R/lmranks_summary.R
\name{lmranks}
\alias{lmranks}
\alias{plot.lmranks}
\alias{predict.lmranks}
\alias{vcov.lmranks}
\title{Rank-Rank Regression}
\usage{
lmranks(
  formula,
  data,
  subset,
  weights,
  na.action = stats::na.fail,
  method = "qr",
  model = TRUE,
  x = FALSE,
  qr = TRUE,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset = offset,
  omega = 1,
  ...
)

\method{plot}{lmranks}(x, which = 1, ...)

\method{predict}{lmranks}(object, newdata, ...)

\method{vcov}{lmranks}(object, complete = TRUE, ...)
}
\arguments{
\item{formula}{An object of class "\code{\link{formula}}": a symbolic description
of the model to be fitted. Exactly like the formula for linear model except that
variables to be ranked can be indicated by \code{r()}. See Details and Examples below.}

\item{data}{an optional data frame, list or environment (or object
    coercible by \code{\link{as.data.frame}} to a data frame) containing
    the variables in the model.  If not found in \code{data}, the
    variables are taken from \code{environment(formula)},
    typically the environment from which \code{lm} is called.}

\item{subset}{currently not supported.}

\item{weights}{currently not supported.}

\item{na.action}{currently not supported. User is expected to handle NA values on their own.}

\item{method}{the method to be used; for fitting, currently only
    \code{method = "qr"} is supported; \code{method = "model.frame"} returns
    the model frame (the same as with \code{model = TRUE}, see below).}

\item{model, y, qr}{logicals. If TRUE the corresponding components of the fit (the model frame, the response, the QR decomposition) are returned.}

\item{x}{\itemize{
\item{For \code{lmranks}: }{Logical. Should model matrix be returned?}
\item{For \code{plot} method: }{An \code{lmranks} object.}
}}

\item{singular.ok}{logical. If \code{FALSE} (the default in S but
    not in \R) a singular fit is an error.}

\item{contrasts}{an optional list. See the \code{contrasts.arg}
    of \code{\link[stats]{model.matrix.default}}.}

\item{offset}{this can be used to specify an \emph{a priori} known
    component to be included in the linear predictor during fitting.
    This should be \code{NULL} or a numeric vector or matrix of extents
    matching those of the response.  One or more \code{\link[stats]{offset}} terms can be
    included in the formula instead or as well, and if more than one are
    specified their sum is used.  See \code{\link[stats]{model.offset}}.}

\item{omega}{real number in the interval [0,1] defining how ties are handled. The value of \code{omega} is passed to \code{\link{frank}} for computation of ranks. The default is 1 so that ranks are defined as the empirical cdf evaluated at the variable. See Details below.}

\item{...}{For \code{lm()}: additional arguments to be passed to the low level
    regression fitting functions (see below).}

\item{which}{As in \code{\link{plot.lm}}. Currently only no.1 is available.}

\item{object}{\code{lmranks} object.}

\item{newdata}{An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.}

\item{complete}{logical indicating if the full variance-covariance matrix 
should be returned also in case of an over-determined system where 
some coefficients are undefined and \code{coef(.)} contains NAs correspondingly. 
When \code{complete = TRUE}, \code{vcov()} is compatible with \code{coef()} also in this singular case.}
}
\value{
An object of class \code{lmranks}, inheriting (as well as possible) from class \code{lm}.
See the \code{\link{lm}} documentation for more.

Additionally, it has an \code{omega} entry, corresponding to \code{omega} argument,
and a \code{rank_terms_indices} - an integer vector with indices of entries of \code{terms.labels} attribute
of \code{terms(formula)}, which correspond to ranked regressors.

A number of methods defined for \code{lm} does not yield theoretically correct 
results when applied to \code{lmranks} objects; errors or warnings are raised consciously.
Also, the \code{df.residual} component is set to NA, since the notion of effects of freedom
for the rank models is not theoretically established.
}
\description{
Estimate a rank-rank regression in which the outcome and/or regressor are ranked.
Optionally, the dataset can be divided into groups and rank-rank regressions can be run
separately within each group, but with ranks computed based on entire dataset 
(for that, see corresponding section below).
}
\details{
This function is useful in case when relationship not between variables themselves, but their rank
(or, put differently, their ECDF value) is of interest. The variables to be ranked
(both dependent and independent) can be marked with \code{r()}. A usual formula would looks like
\code{r(X)~r(Y)+W} or \code{r(X)~r(Y)+.}. In the latter case, both \code{r(X)} and \code{X} will be
included in the model. This behavior is consistent with \code{lm}'s behavior;
one can exclude \code{X} with a \code{-}, i.e. \code{r(Y)~r(X)+.-X}.

The \code{r()} is a private alias for \code{\link{frank}} with fixed
\code{increasing} argument. \code{omega} argument may be specified globally 
(as a specification of rank definition) in the call to \code{lmranks}. 
By default \code{r}'s outcome identical to \code{\link[stats]{ecdf}}.

As a consequence of the order, in which model.frame applies operations, \code{subset} 
and \code{na.action} would be applied after evaluation of \code{r()}. 
In such a case, returned coefficients and standard errors might no longer be correct.
The user must handle the NA values and may filter the data on his own.

Currently, only models at most one rank regressor are available. The single 
response might be either ranked or continuous.

Many functions defined for \code{lm} also work correctly with \code{lmranks}.
This includes \code{\link[stats]{coef}}, \code{\link[stats]{model.frame}},
\code{\link[stats]{model.matrix}}, \code{\link[stats]{resid}} and \code{\link[stats]{update}}. 
On the other hand, some would not return correct results.
}
\section{Methods (by generic)}{
\itemize{
\item \code{plot(lmranks)}: Plot diagnostics for an \code{lmranks} object

Displays plots useful for assessing quality of model fit. Currently, only one
plot is available, which plots fitted values against residuals (for homoscedacity check).

\item \code{predict(lmranks)}: Predict method for Linear Model for Ranks Fits

\item \code{vcov(lmranks)}: Calculate Variance-Covariance Matrix for a Fitted \code{lmranks} object

Returns the variance-covariance matrix of the regression coefficients 
(main parameters) of a fitted \code{lmranks} object.

}}
\section{Rank regression with groups/clusters}{


Sometimes, the data is divided into groups (or \emph{clusters}). The researcher is
interested in running rank-rank regressions separately within each group, but with
ranks computed based on entire dataset. 

This case is implemented and can be specified using formula interaction notation.
Suppose, that G is the name of the grouping variable (it \strong{must} be a \code{factor}),
\code{r(Y)} is the ranked response, \code{r(X)} is the ranked regressor and
\code{W} are the usual regressors. A formula for this model is \code{r(Y)~(r(X)+W):G}.

Since theory for regression with grouped and ungrouped regressors is not developped,
specyfying such a model will raise an error. Also, by default the intercept is 
treated group-wise; \code{r(Y)~(r(X)+W):G} will actually become \code{r(Y)~(r(X)+W):G+G-1}.

\code{\link[stats]{contrasts}} of \code{G} must be of "contr.treatment" kind, which is the default.
}

\section{Warning}{

Wrapping \code{r()} with other functions (like \code{log(r(x))}) will not 
recognize correctly the mark (because it will not be caught in \code{terms(formula, specials = "r")}).
The ranks will be calculated correctly, but their transformation will be treated later in \code{lm} as a regular
regressor. This means, that the corresponding regression coefficient will be calculated correctly,
but the standard errors, statistics etc. will not. 

\code{r}, \code{.r_predict} and \code{.r_cache} are special expressions, used
internally to interpret \code{r} mark correctly. Do not use them in \code{formula}.
}

\examples{
Y <- c(3,1,2,4,5)
y_frank <- c(0.6, 1.0, 0.8, 0.4, 0.2)
X <- 1:5
omega <- 0.5
x_frank <- c(1.0, 0.8, 0.6, 0.4, 0.2)
W <- matrix(y_frank * 0.1 + 5 + rnorm(5, sd = 0.1), ncol = 1)

lmr <- lmranks(r(Y) ~ r(X) + W)
lmr
# naive version with same regression coefficients, but incorrect 
# standard errors and statistics:
lmm <- lm(y_frank ~ x_frank + W)

# Compare:
summary(lmr)
summary(lmm)

# Support of `data` argument:
data(mtcars)
lmranks(r(mpg) ~ r(hp) + ., data = mtcars)
# Same as above, but use the `hp` variable only through its rank
lmranks(r(mpg) ~ r(hp) + . - hp, data = mtcars)

# Grouped case:
G <- factor(rep(LETTERS[1:4], each=nrow(mtcars) / 4))
lmranks(r(mpg) ~ r(hp):G, data = mtcars)
# Include all columns of mtcars as usual covariates:
lmranks(r(mpg) ~ (r(hp) + .):G, data = mtcars)

}
\seealso{
\code{\link{lm}} for details about other arguments; \code{\link{frank}}.

\code{\link{summary.lmranks}}
}
