% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rank_utils.R
\name{irank_against}
\alias{irank_against}
\alias{frank_against}
\title{Compute integer ranks in another reference vector}
\usage{
irank_against(x, v, omega = 0, increasing = FALSE, na.rm = FALSE)

frank_against(x, v, omega = 0, increasing = FALSE, na.rm = FALSE)
}
\arguments{
\item{x}{numeric query vector.}

\item{v}{numeric reference vector.}

\item{omega}{numeric value in [0,1], defining how ties in \code{x} (if any) are handled; default is \code{0}. See Details.}

\item{increasing}{logical; if \code{FALSE} (default), then large elements in \code{x} receive a small rank. Otherwise, large elements in \code{x} receive a large rank.}

\item{na.rm}{logical; if \code{TRUE}, then \code{NA}'s are removed from \code{x}. Default: \code{FALSE}.}
}
\value{
Numeric vector of the same length as \code{x} containing the integer (for \code{irank_against}) or fractional (for \code{frank_against}) ranks.
}
\description{
The method \code{\link{irank}} compares ranks using the same vector as reference.
\code{irank_against} returns integer ranks, that values from \code{x} would assume if (individually)
inserted into \code{v}. \code{frank_against} acts analogously, returning fractional ranks.
}
\examples{
irank_against(1:10, c(4,4,4,3,1,10,7,7))
}
\seealso{
\code{\link[=irank]{irank()}}
}
